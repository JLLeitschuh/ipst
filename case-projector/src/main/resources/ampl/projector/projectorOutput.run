###############################################################################
#
# Copyright (c) 2017, RTE (http://www.rte-france.com)
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# author: Jean Maeght
#
# Projecteur
# Ecriture des resultats
# 
###############################################################################
print "Debut du fichier projectorOutput.run";
printf "Ecriture des resultats\n";

# Il faut desactiver le presolve d'ampl pour forcer le recalcul des variables non utilisees
option presolve 0;


#
# Indicateur relatif au statut final
#
if (solve_result_num >= 0 and solve_result_num < 100) or (solve_result_num >= 400 and solve_result_num < 410) then
  let final_status := "projector_OK";
else
  let final_status := "projector_NOK";



###########################################################################
# 
# Ecriture des groupes
#
###########################################################################

#
# A partir de mai 2018, nouveau format
#

if final_status = "projector_OK" then {
printf '#"num" "bus" "v_regul" "targetV(pu)" "targetP(MW)" "targetQ(MVar)" "P(MW)" "Q(MVar)"\n' > projector_results_generators.txt;
printf {(g,n) in UNIT: n in NOEUDCC}
  "%i %i %s %f %f %f %f %f\n",
  g,
  n,
  # unit_PV[g,n] -> ce qu'il y a dans la situation en entree
  if (g,n) in UNIT_PV then "true" else "false", # Voir definition de UNIT_PV
  V[n],         # Tension issue du calcul. La tension de consigne de la situation en entree n'est pas ecrite ici
  unit_Pc[g,n], # -> ce qu'il y a dans la situation en entree
  unit_Qc[g,n], # -> ce qu'il y a dans la situation en entree
  if (g,n) in UNITCC then unit_P[g,n] else 0, # On peut avoir un groupe raccorde mais avec consignes nulles
  if (g,n) in UNITCC then unit_Q[g,n] else 0  # On peut avoir un groupe raccorde mais avec consignes nulles
  > projector_results_generators.txt;
}

#
# Jusqu'a mai 2018, on ecrit simplement trois colonnes V P Q
#
/* Attention, le signe '/*' marque le debut d'un commentaire long comme en C ou en C++
param unit_P_out{UNIT} default 0;
param unit_Q_out{UNIT} default 0;

let {(g,n) in UNITCC: n in NOEUDCC} unit_P_out[g,n] := unit_P[g,n];
let {(g,n) in UNITCC: n in NOEUDCC} unit_Q_out[g,n] := unit_Q[g,n]; 

if final_status = "projector_OK" then {
# Pas d'espace entre '#' et 'num', pas d'espace en debut de colonne
printf
  "#%s %s %s %s\n",
  "num", "V(pu)", "P(MW)", "Q(MVAR)"
  > projector_results_generators.txt;
printf {(g,n) in UNIT: n in NOEUDCC}
  "%i %f %f %f\n",
  g,
  V[n],
  unit_P_out[g,n],
  unit_Q_out[g,n]
  > projector_results_generators.txt;
}
*/


###########################################################################
# 
# Ecriture des noeuds
#
###########################################################################

printf '#"num" "v(pu)" "theta(rad)"\n'
  > projector_results_buses.txt;
printf {n in NOEUDCC}
  "%i %f %f\n",
  n,V[n],Ph[n]
   > projector_results_buses.txt;


###########################################################################
# 
# Ecriture des branches
#
###########################################################################

printf '#"num" "bus1" "bus2" "p1(MW)" "p2(MW)" "q1(MVar)" "q2(MVar)"\n'
  > projector_results_branches.txt;
printf {(qq,n,m) in QUADCC}
  "%i %i %i %f %f %f %f\n",
  qq,n,m,
  100 * V[n] * Red_Tran_Act_Dir[qq,n,m],
  100 * V[m] * Red_Tran_Act_Inv[qq,n,m],
  100 * V[n] * Red_Tran_Rea_Dir[qq,n,m],
  100 * V[m] * Red_Tran_Rea_Inv[qq,n,m]
  > projector_results_branches.txt;


###########################################################################
# 
# Ecriture des regleurs
#
###########################################################################

printf '#"num" "tap"\n'
  > projector_results_rtc.txt;
printf {(qq,m,n) in QUADCC_REGL}
  "%i %i\n",
  quad_ptrRegl[qq,m,n],
  regl_tap0[quad_ptrRegl[qq,m,n]]
  > projector_results_rtc.txt;


###########################################################################
# 
# Ecriture des dephaseurs
#
###########################################################################

printf '#"num" "tap"\n'
  > projector_results_ptc.txt;
printf {(qq,m,n) in QUADCC_DEPH}
  "%i %i\n",
  quad_ptrDeph[qq,m,n],
  deph_tap0[quad_ptrDeph[qq,m,n]]
  > projector_results_ptc.txt;


###########################################################################
# 
# Ecriture des HVDC
#
###########################################################################

printf '#"num" "convertersMode" "targetP(MW)"\n'
  > projector_results_hvdc.txt;


###########################################################################
# 
# Ecriture des conso
#
###########################################################################

printf '#"num" "bus" "p(MW)" "q(MVar)" "p0(MW)" "q0(MVar)"\n'
  > projector_results_loads.txt;
printf {(c,n) in CONSOCC}
  "%i %i %f %f %f %f\n",
  c,n,
  conso_PFix[c,n],
  conso_QFix[c,n],
  conso_p[c,n],
  conso_q[c,n]
  > projector_results_loads.txt;


###########################################################################
# 
# Ecriture des shunts
#
###########################################################################

printf '#"num" "bus" "b(pu)" "Q(MVar)" "sections_count"\n'
  > projector_results_shunts.txt;
printf {(s,n) in SHUNTCC}
  "%i %i %f %f %i\n",
  s,n,
  shunt_valnom[s,n],
  -shunt_valnom[s,n]*100*V[n]^2, # Dans le fichier ampl_networks_shunts.txt, Q est de signe oppose a celui de b (b==valnom)
  shunt_sections_count[s,n]
  > projector_results_shunts.txt;


###########################################################################
# 
# Ecriture des static var compensators
#
###########################################################################

printf '#"num" "bus" "v_regul" "targetV(pu)" "Q(MVar)"\n'
  > projector_results_static_var_compensators.txt;
printf {(s,n) in SVCCC}
  "%i %i %s %f %f\n",
  s,n,
  if (s,n) in SVC_V then "true" else "false",
  if (s,n) in SVC_V then V[n]   else svc_targetV[s,n],
  if (s,n) in SVC_V then 100*svc_b[s,n]*V[n]^2
  else if (s,n) in SVC_FIXE then svc_Q0[s,n]
  > projector_results_static_var_compensators.txt;


###########################################################################
# 
# Ecriture des lcc converter stations
#
###########################################################################

printf '#"num" "bus" "P(MW)" "Q(MVar)"\n'
  > projector_results_lcc_converter_stations.txt;


###########################################################################
# 
# Ecriture des vsc converter stations
#
###########################################################################

printf '#"num" "bus" "v_regul" "targetV(pu)" "targetQ(MVar)" "P(MW)" "Q(MVar)"\n'
  > projector_results_vsc_converter_stations.txt;
printf {(sc,n) in VSCCONV}
  "%i %i %s %f %f %f %f\n",
  sc,n,vscconv_vregul[sc,n],V[n],vscconv_Q[sc,n],vscconv_P[sc,n],vscconv_Q[sc,n]
  > projector_results_vsc_converter_stations.txt;


###########################################################################
# 
# Ecriture des indicateurs
#
###########################################################################


#
# Indicateur relatif au statut final
#
printf "%s %s\n","final_status", final_status > projector_results_indic.txt;
printf "%s %s\n","solve_result_num",solve_result_num > projector_results_indic.txt;

# Fermeture du fichier pour autoriser l'ecriture directement par le shell
close;

#
# Nom de la situation et du repertoire courant
#
shell 'echo situation $(head -1 ampl_network_substations.txt|cut -d\( -f2 |cut -d\/ -f1) >> projector_results_indic.txt';
shell 'echo repertoire $(basename $PWD) >> projector_results_indic.txt';

# Reouverture du fichier dans ampl pour la suite de indicateurs
printf "" >> projector_results_indic.txt;

# Temps de resolution
printf "%s %s\n","_total_solve_time",_total_solve_time > projector_results_indic.txt;

# Nombre de groupe ayant un domaine dynamique
printf "%s %i\n","nbGroupesDomaine",card(DOMAIN_ID) > projector_results_indic.txt;

# Nombre de coupes pour les domaines dynamiques
printf "%s %i\n","nbCoupesDomaines",card(UNIT_DOMAIN_CTR) > projector_results_indic.txt;

# Nombre de groupes hors Pmin et Pmax
printf "%s %i\n","nbGroupesHorsPmin",card(UNITHORSPMIN) > projector_results_indic.txt;
printf "%s %i\n","nbGroupesHorsPmax",card(UNITHORSPMAX) > projector_results_indic.txt;

# Indicateurs sur les bornes des groupes
printf "%s %i\n","nbGroupesPminInvalide",card({(g,n) in UNITCC: unit_Pmin[g,n] < -9000}) > projector_results_indic.txt;
printf "%s %i\n","nbGroupesPmaxInvalide",card({(g,n) in UNITCC: unit_Pmax[g,n] < -9000}) > projector_results_indic.txt;
printf "%s %i\n","nbGroupesVminInvalide",card({(g,n) in UNITCC: substation_Vmin[unit_substation[g,n]] <= 0})
  > projector_results_indic.txt;
printf "%s %i\n","nbGroupesVmaxInvalide",card({(g,n) in UNITCC: substation_Vmax[unit_substation[g,n]] <= 0})
  > projector_results_indic.txt;


# Somme des P,Q avant apres
printf "%s %.1f\n", "sommePavant", sum {(g,n) in UNITCC} unit_Pc[g,n] > projector_results_indic.txt;
printf "%s %.1f\n", "sommePapres", sum {(g,n) in UNITCC} unit_P[g,n]  > projector_results_indic.txt;
printf "%s %.1f\n", "sommeQavant", sum {(g,n) in UNITCC} unit_Qc[g,n] > projector_results_indic.txt;
printf "%s %.1f\n", "sommeQapres", sum {(g,n) in UNITCC} unit_Q[g,n]  > projector_results_indic.txt;

# Variations totales et moyennes P,Q
let tempo := 1.0 / card(UNITCC);
printf "%s %.1f\n", "variationTotaleP", sum {(g,n) in UNITCC} abs(unit_P[g,n] - unit_Pc[g,n]) > projector_results_indic.txt;
printf "%s %.1f\n", "variationTotaleQ", sum {(g,n) in UNITCC} abs(unit_Q[g,n] - unit_Qc[g,n]) > projector_results_indic.txt;
printf "%s %.2f\n", "variationMoyenneP", tempo * sum {(g,n) in UNITCC} abs(unit_P[g,n] - unit_Pc[g,n]) > projector_results_indic.txt;
printf "%s %.2f\n", "variationMoyenneQ", tempo * sum {(g,n) in UNITCC} abs(unit_Q[g,n] - unit_Qc[g,n]) > projector_results_indic.txt;

# Moyennes Tensions
let tempo := card({(g,n) in UNITCC: unit_PV[g,n]=="true"});
if tempo > 0 then {
  let tempo := 1.0 / tempo;
  printf "%s %.4f\n", "moyenneVnoeudsPVavant", tempo * sum {(g,n) in UNITCC: unit_PV[g,n]=="true"} unit_Vc[g,n] > projector_results_indic.txt;
  printf "%s %.4f\n", "moyenneVnoeudsPVapres", tempo * sum {(g,n) in UNITCC: unit_PV[g,n]=="true"} V[n] > projector_results_indic.txt;
}

# Nombre de groupes modifies P
printf "%s %i\n", "nbGroupesPmodifie01MW",  card({(g,n) in UNITCC : abs(unit_P[g,n] - unit_Pc[g,n]) >= 0.1 } ) > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesPmodifie1MW",   card({(g,n) in UNITCC : abs(unit_P[g,n] - unit_Pc[g,n]) >= 1   } ) > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesPmodifie10MW",  card({(g,n) in UNITCC : abs(unit_P[g,n] - unit_Pc[g,n]) >= 10  } ) > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesPmodifie100MW", card({(g,n) in UNITCC : abs(unit_P[g,n] - unit_Pc[g,n]) >= 100 } ) > projector_results_indic.txt;

# Nombre de groupes modifies Q
printf "%s %i\n", "nbGroupesQmodifie01Mvar",  card({(g,n) in UNITCC : abs(unit_Q[g,n] - unit_Qc[g,n]) >= 0.1 } ) > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesQmodifie1Mvar",   card({(g,n) in UNITCC : abs(unit_Q[g,n] - unit_Qc[g,n]) >= 1   } ) > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesQmodifie10Mvar",  card({(g,n) in UNITCC : abs(unit_Q[g,n] - unit_Qc[g,n]) >= 10  } ) > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesQmodifie100Mvar", card({(g,n) in UNITCC : abs(unit_Q[g,n] - unit_Qc[g,n]) >= 100 } ) > projector_results_indic.txt;

# Nombre de groupes modifies V
printf "%s %i\n", "nbGroupesVmodifie01kV",
  card( {(g,n) in UNITCC: unit_PV[g,n]=="true" and abs(V[n]-unit_Vc[g,n])*substation_Vnomi[unit_substation[g,n]] >= 0.1 })
  > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesVmodifie1kV",
  card( {(g,n) in UNITCC: unit_PV[g,n]=="true" and abs(V[n]-unit_Vc[g,n])*substation_Vnomi[unit_substation[g,n]] >= 1 })
  > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesVmodifie2kV",
  card( {(g,n) in UNITCC: unit_PV[g,n]=="true" and abs(V[n]-unit_Vc[g,n])*substation_Vnomi[unit_substation[g,n]] >= 2 })
  > projector_results_indic.txt;
printf "%s %i\n", "nbGroupesVmodifie5kV",
  card( {(g,n) in UNITCC: unit_PV[g,n]=="true" and abs(V[n]-unit_Vc[g,n])*substation_Vnomi[unit_substation[g,n]] >= 5 })
  > projector_results_indic.txt;


# Groupe ayant le plus varie en P
let tempo := max {(g,n) in UNITCC} abs(unit_P[g,n] - unit_Pc[g,n]);
printf "%s %.1f\n", "variationMaximaleP", tempo > projector_results_indic.txt;
for {(g,n) in UNITCC : abs(unit_P[g,n] - unit_Pc[g,n]) >= tempo } {
  printf "%s %s\n", "groupeVariationMaximaleP", unit_id[g,n] > projector_results_indic.txt;
  }

# Groupe ayant le plus varie en Q
let tempo := max {(g,n) in UNITCC} abs(unit_Q[g,n] - unit_Qc[g,n]);
printf "%s %.1f\n", "variationMaximaleQ", tempo > projector_results_indic.txt;
for {(g,n) in UNITCC : abs(unit_Q[g,n] - unit_Qc[g,n]) >= tempo } {
  printf "%s %s\n", "groupeVariationMaximaleQ", unit_id[g,n] > projector_results_indic.txt;
  }

# Groupe ayant le plus varie en V
let tempo := max {(g,n) in UNITCC : unit_PV[g,n]=="true"} abs(V[n]-unit_Vc[g,n]);
printf "%s %.4f\n", "variationMaximaleVpu", tempo > projector_results_indic.txt;
for {(g,n) in UNITCC : unit_PV[g,n]=="true" and abs(V[n]-unit_Vc[g,n]) >= tempo } {
  printf "%s %s\n", "groupeVariationMaximaleVpu", unit_id[g,n] > projector_results_indic.txt;
  }
let tempo := max {(g,n) in UNITCC : unit_PV[g,n]=="true"} abs(V[n]-unit_Vc[g,n])*substation_Vnomi[unit_substation[g,n]];
printf "%s %.4f\n", "variationMaximaleVkV", tempo > projector_results_indic.txt;
for {(g,n) in UNITCC : unit_PV[g,n]=="true" and abs(V[n]-unit_Vc[g,n])*substation_Vnomi[unit_substation[g,n]] >= tempo } {
  printf "%s %s\n", "groupeVariationMaximaleVkV", unit_id[g,n] > projector_results_indic.txt;
  }


###############################################################################
# Fin du fichier
###############################################################################
print "Fin du fichier projectorOutput.run";

